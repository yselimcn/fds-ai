---
description: TypeScript strict mode enforcement
alwaysApply: true
---

# TypeScript Strict Mode Rules

## NEVER use 'any' - NO ESCAPE HATCHES

```typescript
// ❌ FORBIDDEN
const data: any = fetchData()
const result = data as any
const value = data as unknown as Type
// @ts-ignore
// @ts-expect-error
// @ts-nocheck

// ✅ REQUIRED
const data: unknown = fetchData()
// or properly typed:
const data: UserData = fetchData()
```

## ALL Type Escape Hatches are FORBIDDEN:

- `any` type
- `as any` assertion
- `as unknown as Type` double assertion
- `@ts-ignore` comment
- `@ts-expect-error` comment - If you MUST, add detailed explanation
- `@ts-nocheck` comment
- `{}` as object type
- Non-null assertion `!` without type guard
- Missing function return types
- Implicit any parameters

**If you can't type it properly, you don't understand it**

## Type Everything Properly

- Explicit return types for functions
- Interface for props
- Type for state
- Generics when appropriate

## Interfaces vs Types

- Use interface for object shapes
- Use type for unions, intersections, primitives

## Utility Types

Use built-in utility types:

- Partial, Required, Readonly
- Pick, Omit, Record
- ReturnType, Parameters

## Strict Null Checks

Always handle null/undefined:

```typescript
// ✅ GOOD
const user: User | null = getUser();
if (!user) return <div>Not found</div>;
```

## Required tsconfig.json Settings

Your TypeScript configuration MUST include these settings:

```json
{
    "compilerOptions": {
        "strict": true,
        "noImplicitAny": true,
        "strictNullChecks": true,
        "strictFunctionTypes": true,
        "strictBindCallApply": true,
        "strictPropertyInitialization": true,
        "noImplicitThis": true,
        "alwaysStrict": true,
        "exactOptionalPropertyTypes": true,
        "noUncheckedIndexedAccess": true,
        "noEmitOnError": true
    }
}
```

**NEVER disable ESLint rules. Fix the code instead.**

## Modern TypeScript Operators

Use modern operators for cleaner, safer code:

```typescript
// ✅ REQUIRED: Nullish coalescing (checks null/undefined only)
const value = userInput ?? 'default' // NOT: userInput || 'default'

// ✅ REQUIRED: Optional chaining
const city = user?.address?.city // NOT: user && user.address && user.address.city

// ✅ REQUIRED: Object spread
const updated = { ...existing, name: 'new' } // NOT: Object.assign({}, existing, { name: 'new' })

// ✅ REQUIRED: Prefix unused parameters with underscore
function handleEvent(_event: Event, data: Data) {
    // Use data, _event is intentionally unused
    processData(data)
}
```

## Discriminated Unions - Use Them

Use discriminated unions for state management and exhaustiveness checking:

```typescript
// ✅ REQUIRED Pattern
type Result<T> =
  | { status: 'loading' }
  | { status: 'error'; error: Error }
  | { status: 'success'; data: T }

function handleResult<T>(result: Result<T>) {
  switch (result.status) {
    case 'loading':
      return <Spinner />
    case 'error':
      return <ErrorDisplay error={result.error} />
    case 'success':
      return <DataDisplay data={result.data} />
    default:
      // This ensures all cases are handled
      const _exhaustive: never = result
      throw new Error('Unhandled case')
  }
}

// ❌ FORBIDDEN: Using multiple boolean flags
interface BadState {
  isLoading: boolean
  hasError: boolean
  data?: any
}
```

**NOTE: This pattern applies to ALL state management including:**

- React component state (useState)
- Custom hooks return values
- Async operation states
- Form states

**See also:** `05-state-management.mdc` and `08-architecture.mdc` for implementation examples
