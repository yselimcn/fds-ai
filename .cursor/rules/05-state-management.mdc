---
description: State management patterns and rules
globs:
    - '**/*.tsx'
    - '**/hooks/**'
    - '**/store/**'
alwaysApply: true
---

# State Management Hierarchy

## 1. Local State (useState)

For component-specific state only

## 2. Lifted State

Share between parent-child only when necessary

## 3. Context (sparingly)

Only for truly global, rarely-changing data (theme, user)

## 4. Zustand/Jotai

For complex global state before reaching for Context

## Key Rules:

- NEVER store derived state
- NEVER duplicate state
- Colocate state near usage
- Single source of truth

## Custom Hook Pattern:

Use discriminated unions for state (see TypeScript rules):

```typescript
// ✅ CORRECT: Using discriminated union
type ResourceState<T> =
    | { status: 'loading' }
    | { status: 'error'; error: Error }
    | { status: 'success'; data: T }

function useResource(id: string) {
    const [state, setState] = useState<ResourceState<Resource>>({
        status: 'loading',
    })

    useEffect(() => {
        fetchResource(id)
            .then((data) => setState({ status: 'success', data }))
            .catch((error) => setState({ status: 'error', error }))
    }, [id])

    return state
}

// ❌ FORBIDDEN: Multiple boolean flags (conflicts with TypeScript rules)
// const [isLoading, setIsLoading] = useState(true)
// const [error, setError] = useState<Error | null>(null)
// const [data, setData] = useState<Resource | null>(null)
```

## Form State:

- Use react-hook-form for complex forms
- Controlled components for simple forms
- Always validate on client AND server
