---
description: React best practices and anti-pattern prevention
globs:
    - '**/*.tsx'
    - '**/components/**'
    - '**/hooks/**'
alwaysApply: true
---

# React Best Practices - No Anti-Patterns

## Component Rules

- Single Responsibility: One component, one purpose
- Composition over inheritance
- Props interface always typed with TypeScript
- Prefer function components with hooks

## State Management Anti-Patterns to AVOID:

```typescript
// ❌ BAD: Derived state in useState
const [filteredItems, setFilteredItems] = useState([])
useEffect(() => {
    setFilteredItems(items.filter((item) => item.active))
}, [items])

// ✅ GOOD: Use useMemo for derived state
const filteredItems = useMemo(
    () => items.filter((item) => item.active),
    [items],
)
```

## Hooks Rules:

- Custom hooks start with 'use'
- Extract logic used in 2+ components
- Always return consistent API: { data, error, isLoading }
- Clean up effects properly

## NEVER:

- Use useEffect for derived state
- Mutate state directly
- Use array indexes as keys in dynamic lists
- Put business logic in components (use hooks/utils)
- Create god components (>200 lines)

## EXPLICITLY FORBIDDEN React Patterns:

```typescript
// ❌ FORBIDDEN: useEffect without dependencies
useEffect(() => {
    // This will run on every render
})

// ❌ FORBIDDEN: Key with index
items.map((item, index) => <Item key={index} />)

// ❌ FORBIDDEN: Inline function in render
<Button onClick={() => handleClick(id)} />

// ❌ FORBIDDEN: Nested ternaries
return condition1 ? (
    condition2 ? <A /> : <B />
) : condition3 ? <C /> : <D />

// ❌ FORBIDDEN: Console.log in production
console.log('debug:', data)

// ❌ FORBIDDEN: Missing error boundaries
// Every feature should have error boundary
```

## MANDATORY Error Handling:

**EVERY component that fetches data MUST handle:**

- Loading state
- Error state
- Empty state
- Success state
- **NO EXCEPTIONS**

```typescript
// ✅ REQUIRED Pattern
function DataComponent() {
    const { data, error, isLoading } = useData()

    if (isLoading) return <Skeleton />
    if (error) return <ErrorState error={error} />
    if (!data || data.length === 0) return <EmptyState />

    return <SuccessState data={data} />
}
```

## STOP BEING CLEVER:

- Simple > Clever
- Readable > Concise
- Explicit > Implicit
- Standard patterns > Custom solutions
